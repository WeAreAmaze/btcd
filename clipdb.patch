diff --git a/btcd.go b/btcd.go
index aec55e06..d0b5ec07 100644
--- a/btcd.go
+++ b/btcd.go
@@ -5,7 +5,10 @@
 package main
 
 import (
+	"context"
 	"fmt"
+	"github.com/btcsuite/btcd/btdownoad"
+	"github.com/btcsuite/btcd/wire"
 	"net"
 	"net/http"
 	_ "net/http/pprof"
@@ -14,6 +17,7 @@ import (
 	"runtime"
 	"runtime/debug"
 	"runtime/pprof"
+	"strings"
 
 	"github.com/btcsuite/btcd/blockchain/indexers"
 	"github.com/btcsuite/btcd/database"
@@ -288,18 +292,43 @@ func loadBlockDB() (database.DB, error) {
 		// exist.
 		if dbErr, ok := err.(database.Error); !ok || dbErr.ErrorCode !=
 			database.ErrDbDoesNotExist {
-
 			return nil, err
 		}
+		// todo download bt seed
+		if activeNetParams.Net == wire.MainNet && !cfg.NoClipDB {
+			clipdbPath := filepath.Join(cfg.DataDir, "clipdb")
+			c, err := btdownoad.NewClient(clipdbPath, btdownoad.DefaultTorrentPort)
+			if nil != err {
+				return nil, err
+			}
+			t := btdownoad.LatestTorrent()
+			ctx := context.Background()
+			if err := c.DownloadFromURLs(ctx, t, btcdLog); nil != err {
+				return nil, err
+			}
+			// uncompress
+			from := filepath.Join(clipdbPath, strings.TrimRight(t.Filename(), ".torrent"))
+			to := filepath.Join(cfg.DataDir)
+			files, err := btdownoad.Uncompress(ctx, from, to)
+			if nil != err {
+				return nil, err
+			}
 
-		// Create the db if it does not exist.
-		err = os.MkdirAll(cfg.DataDir, 0700)
-		if err != nil {
-			return nil, err
-		}
-		db, err = database.Create(cfg.DbType, dbPath, activeNetParams.Net)
-		if err != nil {
-			return nil, err
+			// database reopen
+			db, err = database.Open(cfg.DbType, dbPath, activeNetParams.Net)
+			if err != nil {
+				return nil, err
+			}
+		} else {
+			// Create the db if it does not exist.
+			err = os.MkdirAll(cfg.DataDir, 0700)
+			if err != nil {
+				return nil, err
+			}
+			db, err = database.Create(cfg.DbType, dbPath, activeNetParams.Net)
+			if err != nil {
+				return nil, err
+			}
 		}
 	}
 
diff --git a/btdownoad/download.go b/btdownoad/download.go
new file mode 100644
index 00000000..f40ea57e
--- /dev/null
+++ b/btdownoad/download.go
@@ -0,0 +1,239 @@
+package btdownoad
+
+import (
+	"bufio"
+	"context"
+	"errors"
+	"fmt"
+	"github.com/btcsuite/btclog"
+	"io"
+	"net/http"
+	"os"
+	"path/filepath"
+	"runtime"
+	"time"
+
+	lg "github.com/anacrolix/log"
+	"github.com/anacrolix/torrent"
+	"github.com/anacrolix/torrent/metainfo"
+	"github.com/bodgit/sevenzip"
+	"golang.org/x/sync/semaphore"
+)
+
+const TorrentExt = ".torrent"
+const DefaultNetworkChunkSize = 1 * 1024 * 1024
+const DefaultTorrentPort = 42069
+const DownloadSlot = 10
+
+type client struct {
+	cfg      *torrent.ClientConfig
+	filePath string
+}
+
+func NewClient(path string, port int) (*client, error) {
+	if path == "" {
+		return nil, errors.New("path can not be empty")
+	}
+
+	var err error
+	absdatadir, err := filepath.Abs(path)
+	if err != nil {
+		panic(err)
+	}
+	path = absdatadir
+
+	cfg := torrent.NewDefaultClientConfig()
+	cfg.DataDir = path
+	cfg.Logger = lg.Default.FilterLevel(lg.Info)
+	cfg.ListenPort = port
+	cfg.Seed = true
+
+	return &client{
+		cfg:      cfg,
+		filePath: path,
+	}, nil
+}
+
+func (c *client) TorrentClient() (*torrent.Client, error) {
+	tc, err := torrent.NewClient(c.cfg)
+	if nil != err {
+		return nil, err
+	}
+	return tc, nil
+}
+
+func (c *client) DownloadFromURLs(ctx context.Context, t Torrent, log btclog.Logger) error {
+	tc, err := c.TorrentClient()
+	if nil != err {
+		return err
+	}
+	defer tc.Close()
+
+	torrentFileName := filepath.Join(c.filePath, t.Filename())
+	var metaInfo *metainfo.MetaInfo
+
+	if _, err := os.Stat(torrentFileName); os.IsNotExist(err) {
+		// if !common.FileExist(torrentFileName) {
+		response, err := http.Get(t.URL())
+		if err != nil {
+			return fmt.Errorf("error downloading torrent file: %v", err)
+		}
+		defer response.Body.Close()
+
+		metaInfo, err = metainfo.Load(response.Body)
+		if err != nil {
+			return fmt.Errorf("error loading torrent file from %q: %v\n", t.URL(), err)
+		}
+	} else {
+		metaInfo, err = metainfo.LoadFromFile(torrentFileName)
+		if err != nil {
+			return fmt.Errorf("error loading torrent file from %q: %v\n", torrentFileName, err)
+		}
+	}
+
+	tc.AddTorrent(metaInfo)
+
+	var sem = semaphore.NewWeighted(int64(DownloadSlot))
+	go func() {
+		for {
+			torrents := tc.Torrents()
+			for _, t := range torrents {
+				<-t.GotInfo()
+				if t.Complete.Bool() {
+					continue
+				}
+				if err := sem.Acquire(ctx, 1); err != nil {
+					return
+				}
+				t.AllowDataDownload()
+				t.DownloadAll()
+				go func(t *torrent.Torrent) {
+					defer sem.Release(1)
+					<-t.Complete.On()
+				}(t)
+			}
+			time.Sleep(30 * time.Second)
+		}
+	}()
+
+	logEvery := time.NewTicker(5 * time.Second)
+	defer logEvery.Stop()
+
+	statInterval := 5 * time.Second
+	statEvery := time.NewTicker(statInterval)
+	defer statEvery.Stop()
+	ds := NewStats()
+	for {
+		select {
+		case <-ctx.Done():
+			return nil
+		case <-statEvery.C:
+			ds.ReCalcStats(statInterval, tc)
+		case <-logEvery.C:
+			stats := ds.Stats()
+			if stats.MetadataReady < stats.FilesTotal {
+				log.Info("[Download] Waiting for torrents metadata: %d/%d \n", stats.MetadataReady, stats.FilesTotal)
+				continue
+			}
+
+			if stats.Completed {
+				log.Info("[Download] download finished")
+				return nil
+			}
+
+			log.Info("[Download] Downloading",
+				"progress", fmt.Sprintf("%.2f%% %s/%s", stats.Progress, ByteCount(stats.BytesCompleted), ByteCount(stats.BytesTotal)),
+				"download", ByteCount(stats.DownloadRate)+"/s",
+				"upload", ByteCount(stats.UploadRate)+"/s",
+				"peers", stats.PeersUnique,
+				"connections", stats.ConnectionsTotal,
+				"files", stats.FilesTotal)
+			if stats.PeersUnique == 0 {
+				ips := tc.BadPeerIPs()
+				if len(ips) > 0 {
+					log.Info("[Download] Stats", "banned", ips)
+				}
+			}
+		}
+	}
+}
+
+func Uncompress(ctx context.Context, from, to string) ([]string, error) {
+	if !FileExist(from) {
+		return nil, errors.New(from + " not exist!")
+	}
+	if err := os.MkdirAll(to, 0744); nil != err {
+		return nil, fmt.Errorf("create dir failed, %v", err)
+	}
+
+	r, err := sevenzip.OpenReader(from)
+	if err != nil {
+		return nil, err
+	}
+	defer r.Close()
+	var errStr string
+	errCH := make(chan error)
+	go func() {
+		for {
+			select {
+			case <-ctx.Done():
+				return
+			case e := <-errCH:
+				if nil == err {
+					return
+				}
+				errStr += e.Error()
+			}
+		}
+	}()
+
+	var files []string
+	concur := runtime.NumCPU()
+	seg := semaphore.NewWeighted(int64(concur))
+	for i, f := range r.File {
+		if err := seg.Acquire(ctx, 1); nil != err {
+			return nil, err
+		}
+		go func(i int, f *sevenzip.File) {
+			defer seg.Release(1)
+			rc, err := f.Open()
+			if err != nil {
+				errCH <- err
+				return
+			}
+			defer rc.Close()
+
+			tmpF, err := os.Create(filepath.Join(to, f.Name))
+			if nil != err {
+				errCH <- err
+				return
+			}
+			defer tmpF.Close()
+			w := bufio.NewWriter(tmpF)
+			if _, err := io.Copy(w, rc); err != nil {
+				errCH <- err
+				return
+			}
+			w.Flush()
+		}(i, f)
+
+		files = append(files, f.Name)
+	}
+	_ = seg.Acquire(ctx, int64(concur))
+	close(errCH)
+
+	if len(errStr) > 0 {
+		return nil, errors.New(errStr)
+	}
+	return files, nil
+}
+
+// FileExist checks if a file exists at filePath.
+func FileExist(filePath string) bool {
+	_, err := os.Stat(filePath)
+	if err != nil && os.IsNotExist(err) {
+		return false
+	}
+
+	return true
+}
diff --git a/btdownoad/state.go b/btdownoad/state.go
new file mode 100644
index 00000000..6310ca35
--- /dev/null
+++ b/btdownoad/state.go
@@ -0,0 +1,109 @@
+package btdownoad
+
+import (
+	"fmt"
+	"github.com/anacrolix/torrent"
+	"sync"
+	"time"
+)
+
+type AggStats struct {
+	MetadataReady, FilesTotal int32
+	PeersUnique               int32
+	ConnectionsTotal          uint64
+
+	Completed bool
+	Progress  float32
+
+	BytesCompleted, BytesTotal uint64
+
+	BytesDownload, BytesUpload uint64
+	UploadRate, DownloadRate   uint64
+}
+
+type DownloadState struct {
+	statsLock *sync.RWMutex
+	stats     AggStats
+}
+
+func NewStats() *DownloadState {
+	s := new(DownloadState)
+	s.statsLock = &sync.RWMutex{}
+	return s
+}
+func (d *DownloadState) ReCalcStats(interval time.Duration, tc *torrent.Client) {
+	torrents := tc.Torrents()
+	connStats := tc.ConnStats()
+	peers := make(map[torrent.PeerID]struct{}, 16)
+
+	d.statsLock.Lock()
+	defer d.statsLock.Unlock()
+	prevStats, stats := d.stats, d.stats
+
+	stats.Completed = true
+	stats.BytesDownload = uint64(connStats.BytesReadUsefulIntendedData.Int64())
+	stats.BytesUpload = uint64(connStats.BytesWrittenData.Int64())
+
+	stats.BytesTotal, stats.BytesCompleted, stats.ConnectionsTotal, stats.MetadataReady = 0, 0, 0, 0
+	for _, t := range torrents {
+		select {
+		case <-t.GotInfo():
+			stats.MetadataReady++
+			for _, peer := range t.PeerConns() {
+				stats.ConnectionsTotal++
+				peers[peer.PeerID] = struct{}{}
+			}
+			stats.BytesCompleted += uint64(t.BytesCompleted())
+			stats.BytesTotal += uint64(t.Length())
+		default:
+		}
+
+		stats.Completed = stats.Completed && t.Complete.Bool()
+	}
+
+	stats.DownloadRate = (stats.BytesDownload - prevStats.BytesDownload) / uint64(interval.Seconds())
+	stats.UploadRate = (stats.BytesUpload - prevStats.BytesUpload) / uint64(interval.Seconds())
+
+	if stats.BytesTotal == 0 {
+		stats.Progress = 0
+	} else {
+		stats.Progress = float32(float64(100) * (float64(stats.BytesCompleted) / float64(stats.BytesTotal)))
+		if stats.Progress == 100 && !stats.Completed {
+			stats.Progress = 99.99
+		}
+	}
+	stats.PeersUnique = int32(len(peers))
+	stats.FilesTotal = int32(len(torrents))
+
+	d.stats = stats
+}
+
+func (d *DownloadState) Stats() AggStats {
+	d.statsLock.RLock()
+	defer d.statsLock.RUnlock()
+	return d.stats
+}
+
+func ByteCount(b uint64) string {
+	const unit = 1024
+	if b < unit {
+		return fmt.Sprintf("%dB", b)
+	}
+	bGb, exp := MBToGB(b)
+	return fmt.Sprintf("%.1f%cB", bGb, "KMGTPE"[exp])
+}
+
+func MBToGB(b uint64) (float64, int) {
+	const unit = 1024
+	if b < unit {
+		return float64(b), 0
+	}
+
+	div, exp := uint64(unit), 0
+	for n := b / unit; n >= unit; n /= unit {
+		div *= unit
+		exp++
+	}
+
+	return float64(b) / float64(div), exp
+}
diff --git a/btdownoad/torrent.go b/btdownoad/torrent.go
new file mode 100644
index 00000000..b0b287a8
--- /dev/null
+++ b/btdownoad/torrent.go
@@ -0,0 +1,59 @@
+package btdownoad
+
+import (
+	"bufio"
+	dbTorrent "github.com/amazeDevs/btcd-torrents"
+	"strings"
+)
+
+const downloadURL = "https://raw.githubusercontent.com/amazeDevs/btcd-torrents/main"
+
+var dbReleases = split(dbTorrent.LatestTorrent)
+
+func split(txt string) (lines []string) {
+	sc := bufio.NewScanner(strings.NewReader(txt))
+	for sc.Scan() {
+		l := sc.Text()
+		l = strings.TrimSpace(l)
+		if len(l) == 0 {
+			continue
+		}
+		lines = append(lines, sc.Text())
+	}
+
+	if err := sc.Err(); err != nil {
+		panic(err)
+	}
+	return lines
+}
+
+func First(n int, in []string) (res []string) {
+	if n <= len(in) {
+		return in[:n]
+	}
+	return in
+}
+
+type Torrent struct {
+	prefix   string
+	fileName string
+}
+
+func LatestTorrent() Torrent {
+	return Torrent{
+		prefix:   downloadURL,
+		fileName: latestTorrentFile(),
+	}
+}
+
+func (t Torrent) URL() string {
+	return t.prefix + "/" + t.fileName
+}
+
+func (t Torrent) Filename() string {
+	return t.fileName
+}
+
+func latestTorrentFile() string {
+	return First(1, dbReleases)[0]
+}
